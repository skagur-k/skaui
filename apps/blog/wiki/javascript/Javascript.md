---
uuid: 20220606172414
created: 2022-06-06T17:24:14
last-modified: 2022-06-06T17:24:14
alias:
---

# [[Javascript]]

ðŸ“‘ **Tags**:  #note

1. Trying to load a website.
2. `HTML` parser encounters a script tag.
3. `Javascript` is downloaded over the network or the cache.
4. `Stream of bytes` gets returned which gets sent to the Byte Stream Decoder, or parser.
5. `Token` is generated for the rest of the stream.
6. The `parser` generates an `Abstract Syntact Tree` based on the information. 
7. Checks for syntax errors.
8. The `AST` is sent down to the V8 Engine.
9. V8 engine's` Ignition Interpreter `generates byte code.
10. Byte code goes through the Bytecode Optimizers and gets executed.

<iframe width="560" height="315" src="https://www.youtube.com/embed/xckH5s3UuX4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
 


## Compiled Language vs Interpreted Language

**Compiled Language**: the source file is "compiled" to machine code (or byte code) before executed

**Interpreted Language**: the source code will be read and directly executed line by line.

==Javascript is known to be an interpreted language, but this is not necessarily true==

[[Event Loop & Asynchronous  IO#V8 ENGINE|V8 Engine]] compiles the source code to native code internally. V8 increases performance by compiling Javascript to native machine code before executing it.

For example:
^example1

```js
console.log('Hippity Hoppity');  
oops oops;
```

This will spit out error before executing the log function.

Another example (Hoisting):
^example2
```js
max(1, 2);  
// 2
function max(num1, num2){  
  return num1 > num2 ? num1 : num2;  
}
```

The '`max`' function is *hoisted* and is known before-hand, even though the code appears later than the invocation.

## Simple flow of a Javascript applicaton

1. The source code gets transpiled (**Babel**) and packaged (**WebPack**)
2. The JS engine parses the code and tokenizes the keywords.
3. Abstract Syntax Tree (AST) is constructed based on the keywords.
4. The engine converts the AST to a kind-of byte code.
5. The code is converted even further by the JIT compiler.
6. The JS VM executes the program.

> Node js gives us a nice interface to use and relates the JS side of the application to the actual C++ that is running on our computer to actually interpret it in JS code.

For example, Node implements the HTTP module and FS modules, path, crypto, etc.
==All these modules have very consistent APIs â›‘. So you don't have to access the exact C++ code in libuv.==
So with Node js, **you don't have to work with C++ code at all**. You call the Node module whichever required and implement your Javascript code per usual.

## Javscript Compiling Pipeline

![[Pasted image 20220606173342.png]]

### V8 Ignition

`Ignition` is a bytecode interpreter for `V8`. It takes a bytecode source and optimizes it to generate much smaller bytecode and remove unused code. 

`Ignition` takes the whole script, parses it and compiles all at once. The *AST*, which was the source of truth for the compilers, is now passed into Ignition which walks all nodes and generates bytecode that is the *new source* for all compilers.

After walking the  AST, the generated bytecode is feeded one at a time to an optimization pipeline.

![[Pasted image 20220606173643.png]]

![[Pasted image 20220606173908.png]]

### TurboFan

TurboFan is the JS optimizing compiler. Uses what is called a Sea of Nodes Representation.

![[Pasted image 20220606182108.png]]

### ByteCodes

Bytecodes are abstractions of machine codes. Something between the code we can read and the code machines execute.  Bytecode is *machine agnostic*: bytecodes can be compiled into whatever machine architecture you're running on. 

**Bytecode** is translated into **assembly/machine code** which can be sent to the processor and executed.

![[Pasted image 20220606182350.png]]

## ðŸ”Ž References

- 

## ðŸ“‡ Additional Metadata

- ðŸ—‚ Type:: #type/note
